'''
A so called REST-API, which is based on http-Requests, which are
the protocol underlying all your internet browsers;
data/functionality is reachable with an URL (consisting of the
API/Servername + the path to the ressource). In this example, we
don't have a real API, but a classic webserver, but as you only can
read in data with pandas (aka do a GET-request to the server)
anyway, most APIs should work the same (you probably need
something called “API-Key”/“token” for most commercial cases!).
In this example, we will read in open source environmental quality
data (noise/pressure/air/...) at various stations around the world
and do data-aggregation. For a given date (in ISO-format
2021-11-15) and sensor number (just digits), you can get
measurements in ;-separated csv-format at:
https://archive.sensor.community/<date>/<date>
bme280 sensor <sensornumber>.csv.
In the second exercise, use pandas to directly fetch this data into a
DataFrame from the URL! BE CAREFUL AND START WITH
A SUBSET OF STATIONS/DATES FOR DEVELOPING
THE DOWNLOAD CODE (and then work from the data
csv!)!. Be aware, that files might be missing, resulting in read csv
producing an urllib . error .HTTPError. Make sure you deal with that.
You can just read a csv directly from the internet, passing a
suitable url to read csv.
3.1 Read in the json-file station . json to a dictionary (the key is the
station number) and then create a Dataframe using the dictionary
key as an index and expanding the value dictionaries to columns.
Save this as stations .csv
3.2 Now read in the data for the given sensor locations on the first 14
days of October 2021 to pandas dataframes.
Hint: read csv on the url will return a multicolumn df with an
autogenerated index. You can use pd.concat to create a large
dataframe, which you can store in a file (default csv-format, sort the
stations numerically befor concatenation!). Set the keyword
parameter ignore index=True to get a unique index.
Note: how do read csv and to csv treat the index?
3.3 Now, for each day, find the station with the lowest recorded
pressure/temperature/humidity and store the station-id together
with the value in a dataframe like this (set the day as an index if
possible) and store in a csv.
3.4 For every station, output the total number of temperatures greater
than 20 units AND the total number of measurments of the stations
(varies across stations!)
3.5 Explore the plotting functionality of pandas: for two stations, plot
the temperature and the pressure between 2021-10-04 and
2021-10-11 12:00 (respective local times!). For this create two
dataframes including the time and the temperature/pressure for
respective sensors, and change the T/p-columnname to reflect the
sensor id.
Then use the x and y-arguments of the . plot-function on the first
dataframe and store the returned axis object in a variable to be able
to use the same plot surface again. Then pass this to the second df
. plot call as a kw-argument ax=ax1, before running plt .show().
3.6 Finally, for 4 selected sensors, create histograms of the humidity.
You can use DataFrame.hist(), which has a nice kw-argument by,
which specificies a column used to create a subselection to create a
'''


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from urllib.error import HTTPError
import json

from pandas.core.reshape.concat import concat

#https://archive.sensor.community/<date>/<date>_bme280 sensor <sensornumber>.csv

#open the json file to a dictionary
with open('stations.json', encoding='utf-8') as f:
    d=json.load(f)
stations=pd.DataFrame.from_dict(d, orient='index')
stations.sort_index()
stations.to_csv("stations.csv")

dates=['01','02','03','04','05','06','07','08','09','10', '11', '12', '13', '14']
#uf_date='2021-10-{}'
df_list=[]
for date in dates: 
    count=0
    nesteddf_list=[]

    uf_date='2021-10-{}'
    f_date= uf_date.format(date)

    for sen_id in d.keys():
        #uf_date='2021-10-{}'
        #f_date= uf_date.format(date)
        unformated_string="https://archive.sensor.community/{}/{}_bme280_sensor_{}.csv"
        url=unformated_string.format(f_date, f_date, sen_id)
        #print(url)
        try:
            csv_file=pd.read_csv(url, sep=';', index_col='timestamp')
            count+=1
            nesteddf_list.append(csv_file)
        except HTTPError:
            pass
    
    temp_combined_csv=pd.concat(nesteddf_list)
    df_list.append(temp_combined_csv)

final_csv=pd.concat(df_list)
final_csv.index= pd.to_datetime(final_csv.index)
final_csv.to_csv('final.csv')

#Aufgabe 4-3-3
pressure_min=[]
pressure_min_idx=[]
temperatur_min=[]
temperatur_min_idx=[]
humidity_min=[]
humidity_min_idx=[]
days_list=[]
for day in dates:
    f_day=uf_date.format(day)
    days_list.append(f_day)
    #"2021-10-01"

    pressure_min.append(final_csv.loc[f_day, 'pressure'].min())
    temp=final_csv.loc[f_day, 'pressure'].idxmin()
    pressure_min_idx.append(final_csv.loc[temp, 'sensor_id'])

    temperatur_min.append(final_csv.loc[f_day, 'temperature'].min())
    temp=final_csv.loc[f_day, 'temperature'].idxmin()
    temperatur_min_idx.append(final_csv.loc[temp, 'sensor_id'])

    humidity_min.append(final_csv.loc[f_day, 'humidity'].min())
    temp=final_csv.loc[f_day, 'humidity'].idxmin()
    humidity_min_idx.append(final_csv.loc[temp, 'sensor_id'])

    final_csv.loc['2021-10-01','humidity'].to_csv('check.csv')

days_df=pd.DataFrame(days_list)
pressure_min_df=pd.DataFrame(pressure_min)
pressure_min_idx_df=pd.DataFrame(pressure_min_idx)
temperatur_min_df = pd.DataFrame(temperatur_min)
temperatur_min_idx_df=pd.DataFrame(temperatur_min_idx)
humidity_min_df=pd.DataFrame(humidity_min)
humidity_min_idx_df=pd.DataFrame(humidity_min_idx)

minimum_df=pd.concat([days_df, pressure_min_df, pressure_min_idx_df, temperatur_min_df, temperatur_min_idx_df, humidity_min_df, humidity_min_idx_df], axis=1)
minimum_df.columns=['date','min_p', 'min_p_loc', 'min_T', 'min_T_loc', 'min_humidity', 'min_humidity_loc']
minimum_df=minimum_df.set_index('date')
minimum_df.to_csv('mindf.csv')

#Aufgabe4-3
with open('3_4.txt', 'w') as f:
    for station in list(d.keys()):
        #print(type(station))

        temp_df=final_csv[final_csv['sensor_id']==int(station)]
        p="test{}.csv"
        #temp_df.to_csv(p.format(station))
        temp_df2=temp_df[temp_df['temperature']>20]
        output="{}: {}/{}\n"
        f.write(output.format(station, len(temp_df2), len(temp_df)))

#Aufgabe4-4
start_date=np.datetime64('2021-10-04')
end_date=np.datetime64('2021-10-11T12:00')

temp_df3=final_csv[final_csv['sensor_id']==21779]
temp_df4=final_csv[final_csv['sensor_id']==11114]

temp_df5=temp_df3[(temp_df3.index>=start_date) & (temp_df3.index<=end_date)]
temp_df6=temp_df4[(temp_df4.index>=start_date) & (temp_df4.index<=end_date)]

temp_df7=temp_df5[['sensor_id', 'pressure','temperature']]
temp_df8=temp_df6[['sensor_id', 'pressure','temperature']]
temp_df8.columns=['sensor_id2', 'pressure2', 'temperature2']

temp_df9=pd.concat([temp_df7, temp_df8], axis=1)
temp_df9['timestamp']=temp_df9.index
temp_df9.to_csv("4-4.csv")

ax1 = temp_df7.plot(kind='line' ,y='pressure')
ax3 = temp_df8.plot(kind='line' ,y='pressure2', ax=ax1)
plt.savefig('4_41.png')
ax2 = temp_df7.plot(kind='line',y='temperature')
ax4 = temp_df8.plot(kind='line' ,y='temperature2', ax=ax2)
plt.savefig('4_42.png')


#Aufgabe5

print("plotting now")
final_csv.hist('humidity' ,by=final_csv['sensor_id'], bins=[0,20,40,60,80,100])
plt.savefig('4_5.png')
plt.show()